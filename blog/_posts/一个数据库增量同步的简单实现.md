---
title: 一个数据库增量同步的简单实现
date: 2020/02/26
author: Zjm
location: Hangzhou
tags:
    - Python
    - Flask
    - DB
---

# 一个数据库增量同步的简单实现

> 最初的想法要从上学期结束前，我开始设计去哪吃饭系统开始说起。那时候我还没了解到`localStorage`和`indexedDB`，因此想当然地认为要实现数据的持久化存储只能再搭建一个简单的后端。趁着放假，我又仔细思考了一下原来的设计，决定还是加上`indexedDB`，在前端实现数据的持久化，这样以后做PWA也方便。
>

## 核心目标

- 首先，利用`localStorage`和`indexedDB`，可以在前端缓存下数据库，在网络条件允许时再尝试上传至后端数据库，应用即可完全脱离后端运行。
- 后端数据库需要能够合并来自不同设备的记录，并保持各个设备在同步后保持一致的状态。
- 冲突处理：不同设备可能提交对同一记录不同的更改，后端在理想情况下应当针对这种冲突行为提出警告。但由于这种情况较少发生，并且在项目中不对数据完整性作严格的要求，因此这里采用了最后修改时间作为合并标准，较晚修改的记录将覆盖较早修改的记录。

## 数据库设计

### 前端部分

前端使用`localStorag`存储`last_sync`字段，该字段保存当前客户端的上次同步时间（时间戳形式）。

其余数据使用`indexedDB`存储，如下表所示：

| 字段名        | 描述                           |
| ------------- | ------------------------------ |
| id            | 记录的唯一标识符，下面详细说明 |
| last_modified | 记录最后修改时间               |
| status        | 记录状态(0-正常/1-删除)        |
| ...           | 实际payload                    |

其中id为记录提供了全局唯一的标识，形式为UUID。

***

**不提供该字段会怎样？**

不提供该字段，对于前端来说影响不大。因为有`last_modified`字段的存在，修改依然可以正常地被推送到后端数据库。但是后端数据库仍然需要一组主键来定位后续的修改操作。但是如果主键依赖于后端数据库的生成，就需要区分新增和修改两种操作：

- *前端的新增操作在同步时不需要传输主键，后端收到后为其分配一个主键，发送给前端，前端收到后修改数据库中主键为返回值，并移除新建标记*
- 修改操作需要传输主键，后端根据主键找到对应记录进行修改即可

这样操作可能会导致前端具有许多不明确主键的记录，不如直接使用uuid创建全局唯一标识符作为id更为优雅。

**为什么要用UUID？**

假设这里使用自增的方式生成id，那么不同的终端在使用时可能会产生相同的id，在同步时会认为是同一个记录，从而产生覆盖等现象。

### 后端部分

后端使用`SQLite`数据库存储，如下表所示：

| 字段名        | 描述                                   |
| ------------- | -------------------------------------- |
| id            | 记录唯一标识符，同前端定义             |
| last_modified | 最后修改时间，同前端定义               |
| status        | 记录状态，同前端定义                   |
| last_push     | 最后推送时间，即该记录在后端的修改时间 |
| …             | 实际payload                            |

**为什么要新增`last_push`字段？**

因为可能存在如下情况：

| 时间 | A终端     | B终端 | 备注                                                        |
| ---- | --------- | ----- | ----------------------------------------------------------- |
| 1    | 修改记录1 |       | A最后修改时间=1                                             |
| 2    |           | 同步  | B最后同步时间=2                                             |
| 3    | 同步      |       | A最后同步时间=3                                             |
| 4    |           | 同步  | 应拉取1-3的信息，但如果缺少`last_push`，会导致拉取为3的信息 |

简单地说，后端需要处理==在上一次同步后同步上来的信息==而不是==修改时间在上一次同步后的信息==，这是因为修改信息和同步操作不一定发生在同一时刻。

***

未完待续